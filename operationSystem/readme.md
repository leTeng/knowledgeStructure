

二、计算机信息的表示和处理

    


三、程序机器代码表示

    3.1 机器代码的基础
                   
                  编译器                         链接器
        (1) 源代码 ------> 汇编代码(机器代码的文本) --------> 机器代码
    
        (2) 寄存器：
        
                --程序计数器：记录下一个指令的内存地址。 
                --整数寄存器：存储整数,状态,内存地址,临时数据(参数,局部变量,返回值)
                --条件码寄存：保存最近的执行算数和逻辑指令的状态信息。主要实现if、while
                --向量寄存器：存储一个或者一组整数或者浮点数。
                
        (3) 汇编代码和机器代码的区别：
        
                -- x86-64的一条指令的程度为0-15个字节不等。常用的指令的字节数较少,
                        不常用的指令的字节数较长。
                -- 每个指令都对应唯一的开头字节, 如 pushq %rdx , pushq 对应的机器
                        代码为53开头。
                -- 汇编代码可以根据机器代码的序列生成,可以不需要通过源代码编译生成。
        
        
    3.2 指令的构成
    
        (1) 数据格式
        
            声明       intel数据类型          指令后缀        大小(字节)
            
            char          字                   b             1
            short        双字                  w             2
            int          四字                  l             4
            long         八字                  q             8
            float       单精度                 s             4
            double      双精度                 l             8
            
            注意：int 和 double使用相同的指令后缀,但是他们的执行指令是不一样的,
                 并且使用的寄存器也不一样。      
                 
        (2) 整数寄存器分析
        
            字节    61               31              15          7       0         描述
                
            寄存器  %rax             %eax            %ax         %al               存储返回值 
                   %rbx             %ebx            %bx         %bl               别调用者保存  
                   %rcx             %ecx            %cx         %cl               第四个参数  
                   %rdx             %edx            %dx         %dl               第三个参数  
                   %rsi             %esi            %si         %sil              第二个参数  
                   %rdi             %edi            %di         %dil              第一个参数
                   %rbp             %ebp            %bp         %bpl              被调用者保存        
                   %rsp             %esp            %sp         %spl              栈指针 
                  
                   %r8              %r8d            %r8w        %r8b              第五个参数           
                   %r9              %r9d            %r9w        %r9b              第六个参数  
                   %r10             %r10d            %r10w        %r10b           调用者保存  
                   %r11             %r11d            %r11w        %r11b           调用者保存  
                   %r12             %r12d            %r12w        %r12b           被调用者保存
                   %r13             %r13d            %r13w        %r13b           被调用者保存
                   %r14             %r14d            %r14w        %r14b           被调用者保存
                   %r15             %r15d            %r15w        %r15b           被调用者保存
                   
                   解释：扩展到IA32架构时,扩展了8个证书通用寄存器。每个寄存器都有64个位存储数据。
                        -- 每个寄存器提供4种访问方式：
                           指令后缀： 
                                    b: 访问寄存器最低8位
                                    w: 访问寄存器最低16位
                                    l: 访问寄存器最低32位
                                    q: 访问寄存器最低64位(整个寄存器)
                   
                   寄存器具有一组标准管理栈,参数传递,返回值,局部变量和临时数据。
            
            (3) 操作数的表示
                    
                 -- 操作数分类：
                        
                        立即数：$10,存储在寄存器或者内存中。
                        内存地址：M[addr],计算内存地址,访问内存地址的值。
                        寄存器：R[ra],R代表寄存器集合,ra代表寄存器的索引。
                                每个寄存器中的0-7,0-15,0-31,0-63的字节序列代表一个操作数。   
                 
                 -- 寻址方式：
                    
                        类型                  格式              操作数值            名称
                         
                       立即数                 $Imm               Imm              立即寻址
                       寄存器                  ra                R[ra]            寄存器寻址
                       存储器                 Imm                M[Imm]           绝对寻址
                       存储器                 (ra)               M[R[ra]]         间接寻址
                       存储器                 Imm(rb)            M[Imm+R[ra]]     寻址(基址+偏移量)
                       存储器                 (rb,ri)            M[R[ra] + R[rb]] 变址寻址
                       存储器                 Imm(rb,ri)         M[Imm+R[ra]+R[rb]] 变址寻址 
                       存储器                 (,r,s)             M[R[ri*s]]       比例变址寻址
                       存储器                 Imm(,r,s)          M[Imm+R[ra]*s]   比例变址寻址
                       存储器                 (ra,rb,s)          M[R[ra]+R[rb]*s] 比例变址寻址
                       存储器                 Imm(ra,rb,s)       M[Imm+R[ra]+R[rb]*s] 比例变址寻址
                       
                       注意比例因子(s)的值必须为： 1 2 4 8 ... 2^n。    
                       
    
    3.3 指令
    
            (1) 数据传送指令
                    
                    指令                  效果                  描述
                    
                    MOV  S D            S --> D                传送 
                    movb                                       传送字节
                    movw                                       传送双字
                    movl                                       传送四字
                    movq                                       传送八字
                    movabsq                                    传送绝对四字
                    
            注意：传送指令中的操作数的源操作数和目的操作数不能都是内存地址,如果是内存地址传送到内存地址,
                要通过两条指令。其中一条将源数据传送到寄存器,另一条从寄存器传送到内存地址。mov指令只会
                更新寄存器指定位置的字节。如 movb 0x03 %rdx 只会改变%rdx的后面8位字节。就比较例外的
                是movl,他会将未涉及的4个字节高位设置为0。                                                                 
            
            (2) 扩展字节传送
            
                --零扩展(0)
                    
                     指令                 效果                  描述
                    
                    MOVZ S Z            Z <--(零扩展)S         以零扩展传送到目的操作数
                        
                    movzbw                                    将做了零扩展的字节传送到字   
                    movzbl                                    将做了零扩展的字节传送到双字   
                    movzbq                                    将做了零扩展的字节传送到四字    
                    movzwl                                    将做了零扩展的字传送到双字    
                    movzwq                                    将做了零扩展的字传送到四字   
                    
                --符号扩展(1)                                        
                
                    MOVS S Z            Z <--(符号扩展)S       以符号扩展传送到目的操作数
                        
                    movsbw                                    将做了符号扩展的字节传送到字   
                    movsbl                                    将做了符号扩展的字节传送到双字   
                    movsbq                                    将做了符号扩展的字节传送到四字    
                    movswl                                    将做了符号扩展的字传送到双字    
                    movswq                                    将做了符号扩展的字传送到四字
                    movslq                                    将做了符号扩展的双字传送到四字
                    cltq               %rax <-- %eax          将%eax符号扩展到%rax
                    
                    1.movz 比 movs 少了一条movzlq指令,因为movl指令已经实现了该指令(movl会自动进行零扩展)。
                    2.cltq指令只作用%rax(函数返回值寄存器)寄存器,其不需要操作数。默认指定操作数源和目标都是%rax。
                    
                    
    3.4 栈操作指令 
    
            (1) 指令
            
                指令                  效果                           描述 
                    
                pushq   S           R[%rsp] <-- R[%rsp] - 8         将四节压栈
                                    M[R[%rsp]]<-- s    
                
                popq    D           D <-- R[%rsp]                   将四节弹栈
                                    R[%rsp] <-- R[%rsp] + 8      
                    
                
                注意：当前描述的栈是倒过来的,当压栈的时候。栈顶指针-8,向下扩展了8个字节,
                        然后将四字的元素S压入栈中,压栈的目的操作数是内存地址。弹栈时将
                        栈顶的四字字节写入寄存器,并将数组保留栈中(直到覆盖),栈顶指针+8。
                    
    3.5 算数和逻辑操作指令
    
            (1) 加载有效地址
                    
                   指令               效果                 描述
                    
                   leaq S D          D <-- &S             加载有效地址 
                   
                   注意：leaq是一种 mov指令的变种。其将源操作数进行的算术,得出的结果为医德地址值
                        然后在传送到目的操作数。目的操作数必须为寄存器。
                    
            (2) 一元操作
            
                   指令               效果                 描述
                   
                   INC   D           S <-- D + 1          加1
                   DEC   D           S <-- D - 1          减1  
                   NEG   D           D <-- -D             取负  
                   NOT   D           D <-- ~D             取反  
                   
                  注意：一元操作数的源操作数和目的操作数可以是寄存器或者内存地址。
                           只有一个操作数,其中操作数是源也是目的。有点类似java
                           中的自增操作符(++)和自减(--)。
                  
            (3) 二元操作
                    
                   指令              效果                  描述
                   
                   ADD  S D         D <-- S+D              加           
                   SUB  S D         D <-- S-D              减
                   IMUL S D         D <-- S*D              乘      
                   XOR  S D         D <-- S^D             异或
                   OR   S D         D <-- S|D              或
                   AND  S D         D <-- S&D              并
                   
                   注意：二元操作的有两个操作数,其中第二个操作数是目的操作也是源操作数,
                        第一个操作数可以是一个立即数、寄存器或者内存地址。第二个操作数
                        只能是寄存器或者内存地址。当第二个操作数是内存地址时，处理器必
                        须从内存读出值，执行操作再把值写回内存。二元操作有点类似java
                        中的x+=y。
                        
            (4) 移位                        
                   
                   指令                   效果                 描述 
                   
                   SAL  S K          S <--S << K             算数左移K位(等同逻辑左移)                   
                   SHL  S K          S <--S << K             逻辑左移K位
                   SAR  S K          S <--S >> K             算数右移(有符号)
                   SHR  S K          S <--S >> K             逻辑右移K位 
                   
                    注意：移位指令有两个操作数,第一个操作数作为源又作为目的。第二个操作数
                          是移位的数。移位数可以是立即数或者寄存器%cl的单字节数。一个字节
                          可以移位255位,所以移位数是由%cl的低位m个决定的。如salb，移位数
                          是%cl最低4个位。salw 移位数是%cl的最低8位。其中移位存在逻辑移位
                          和算术移位。如果是无符号数,执行逻辑移位。如果是有符号数,左移使用
                          逻辑移位,右移使用算术移位。
                          
    3.6 特殊的算术操作
    
    
    3.7 控制指令                            
        
        (1) 条件码寄存器
        
            寄存器             类型               描述    
                
              CF             进位标志         最近的操作使得高位产生了进位。可用检查无符号操作的溢出         
              ZF             零标志           最近的操作得出的结果为0 
              SF             符号标志         最近的操作得到的结果为负数
              OF             溢出标志         最近的操作导致一个补码溢出(正溢出和负溢出)
              
      
      
        (2) 设置条件码
        
            描述：把最近算术或者逻辑操作的结果设置条件码寄存器。会影响条件码的算术和逻辑操作指令
                 包括算术：INC、DEC、ADD、SUB、IMUL,逻辑： ENG、NOT、XOR、OR、END等。
                 其中leaq指令不会设置条件码,INC、DEC会设置也出标志和零标志,不会设置进位标志。
                 逻辑操作进位标志和溢出标志会设置为0。移位操作进位标记设置为最后一个被溢出的位,
                 而溢出标记设置为0。
                 
            扩展：
            
                除了逻辑、算术操作会设置状态码之外,还有两个指令会设置状态码。分别是：comp、test
                
                --CMP 指令：
                    
                    描述：cmp指令需要两个操作数,类似于sub指令,但是cmp指令是不改变操作寄存器
                         的值的。只会设置条件码寄存器。cmp有四种分类指令,分别对应不同的字节
                         大小。
                    
                    指令                  效果              描述
                    
                    cmpb  S1  S2         S2 - S1          比较字节
                    cmpw  S1  S2                          比较字  
                    cmpl  S1  S2                          比较双字
                    cmpq  S1  S2                          比较四字
                    
                    示例：
                    
                    CF(进位):  0   0   0   0
                    ZF(零):   0   0   0   0
                    SF(负):   0   1   1   0
                    OF(溢出): 1   0   1   0
                      
                    case                result                        desc 
                      
                      a<b               cmpq a b = a - b > 0         发生了负溢出
                      a<b               cmpq a b = a - b < 0         正常
                      a>b               cmpq a b = a - b < 0         发生了正溢出   
                      a>b               cmpq a b = a - b > 0         正常
                
                
                --TEST指令：
                
                     描述：TEST指令同样是设置条件码寄存器的值不修改寄存器的值。与AND指令类似
                          其中TEST指令有一个典型的使用方式,就是两个操作都是一样。如testq 
                          %rax %rax 用来检查 %rax 是正数(true)、负数、0(false)。
                       
                       
                     示例：
                          
                       CF(进位):  0   0   0   
                       ZF(零):   0   0   1   
                       SF(负):   0   1   0   
                       OF(溢出): 0   0   0                        
                     
                     case                    result                               desc
                     
                    %rax = 1            testq %rax  %rax = 0001 & 0001 = 0001     正数(true)          
                    %rax = -1           testq %rax  %rax = 1111 & 1111 = 1111     负数  
                    %rax = 0            testq %rax  %rax = 0000 & 0000 = 0000      0(false)
   
   
        (3)访问条件码寄存器三种方式
        
            
             1.条件码组合方式
                
                将多个条件码寄存器通过逻辑运算符组合把一个字节设置0或者1。这类指令为SET指令,
                SET指令的后缀表示了不同的指令组合。
                
                
                SET指令：
                
                    指令              同义词             组合表达式                   组合结果
                    
                    sete    D         setz               D <-- ZF                   相等/零
                    seteq   D         setnz              D <-- ~ZF                  不相等/非零
                    
                    sets    D                            D <-- SF                   负数        
                    setns   D                            D <-- ~SF                  非负数   
                    
                    setg    D         setnle             D <-- ~(SF & OF) & ~ZF     大于(有符号 >)
                    setge   D         setnl              D <-- ~(SF ^ OF)           大于等于(有符号 >=)
                    setl    D         setnge             D <-- SF ^ OF              小于(有符号 <) 
                    setle   D         setng              D <-- (SF ^ OF) | ZF       小于等于(有符号 <=)   
                    
                    seta    D         setnbe             D <-- ~CF & ~ZF            超过(无符号 >)
                    setae   D         setnb              D <-- ~CF                  超过或等于(无符号 >=)
                    setb    D         setnae             D <-- CF                   低于(无符号 <) 
                    setbe   D         setna              D <-- CF | ZF              低于或等于(无符号 <=)
             
             2.条件跳转到程序某个部分
             3.有条件传送数据
   
   
    3.8 循环指令
     
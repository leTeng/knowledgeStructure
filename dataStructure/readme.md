
                                                  数据结构笔记
  一、抽象的数据类型（ADT）

        1. ADT 是一组带有操作的对象集合，如表、树等。他们是一个数据集合的抽象。

  二、 表

        1.普通表

            1.1 add()、remove() 在前端操作是花费高昂的(O(n)),所有的数据都要向后（前）移动一位。
            1.2 findKth(i) 该操作花费为 O(1)

        2.链表

            2.1 add()、remove() 在前端操作是花费高昂的(O(1)),所有的数据只是交换一下前后的引用。（还有分配空间）
            2.2 findKth(i) 该操作花费wei O(n),该操作没有普通表的高效( 因为普通表的存储是连续的,地址及计算是O(1) )。

        3.Collcetion 接口

            3.1 是 java 对数据结构的实现的定义。表（ArrayList、linkedList）就是其中的一种定义。

            3.2 其中 Collection 接口扩展了 Iterator 接口 ,
                每一个Collection 都要提供Iterator的实现（提供该接口的迭代方式）。

            3.3 Collection的实现能否使用ForEach,需要实现Iterator。ForEach依赖Iterator.

       4.Iteraor 接口
       
            4.1 Iterator 提供三个接口定义：hasNext() , next() , remove()
            
                4.1.1 hasNext(): 判断是否有下一项,初始值为 0, 每次调用next()，会向下推进一位。
                4.1.2 next(): 获取当前项，并将当前的光标向下推进一位。(
                                注意：获取迭代器时，保存当前modCount,每次操作前都对比modCount和
                                      获取迭代器时的modCount，如果不相等，迭代器是非法的。抛出 ConcurrentModificationException )
                4.1.3 remove(): 迭代器可以保存当前项。对当前项进行删除是很高效的。
       
  
  二、栈(Stack)     
  
        1. 定义：限制了插入和刪除只能在一个位置进行操作，也就是表的末端(栈顶)。操作也只有两种，
                 push(压栈、入栈) 和 pop(弹栈、出栈)。top 表示一个指针，永远指向栈顶。
                 
        2.特性：先进后出、后进先出
        
        3.实现：可以使用表的ADT(ArrayList 或 LinkedLilst)。因为只有push 和 pop。并在表的末端操作
                所以相对简单。并且每次 push 、 pop 操作都是常数(O(1))时间。   
                
        4.应用
        
            4.1 编译器的语法检验
            
                具体步骤：
                
                        对文本的每个字符遍历，如遇到 ( {  [  / 将改字符压栈，如果出现封闭符号，抛错。
                        遇到/,判断栈顶元素是否对应。如果不抛错。否则弹栈。如果文件读到结尾，
                        栈中还有元素抛错。
                        
            4.2 简单的计算器      
                
                    4.2.1 后缀表达式计算
                    
                          (2*3+5)/6 --> 23*5+6/
                          2*5+22-10/12 --> 25*22+10/12-
                          
                          算法：
                                2 5 * 22 + 10 / 12 -
                                将数据读入：2 5  stack --> 2 5
                                    遇到 * ，弹栈 2*5 = 10 压栈  stack --> 10
                                将数据读入：22   stack --> 10 22
                                    遇到 + ，弹栈 10+22 = 32 压栈  stack --> 32
                                        
                                        以此类推....
                                        
                    4.2.2 中缀表达式转换为后缀表达式                                  
                     
                           中缀 --> 后缀
                           2*5+22-10/12 --> 25*22+10/12-
                           
            4.3 程序运行方法调用栈使用
                
              4.3.1 当主调进程有新的方法调用时,防止新方法的变量覆盖了主调进程的变量,将主调进程的
                     变量和地址存放栈里面。当新方法执行后，获取到返回地址，并恢复主调进程的变量。           
  
  二、树
  
        1.定义：
            
            1.1 树右一个根节点和N个节点，一条边连接子树或子节点。有N-1条边。如果节点下没有子节点，
                    该节点称为树叶。具有具有相同父节点的节点称为兄弟节点。
                
            1.2 从一个节点到任意一个节点的只有一条路线，这条路线的称为路径。
            
            1.3 深度和高的区别 ：
                    深度是根节点到节点的路径长度。
                    高是目标节点到树叶最长路径。
                        注意：一棵树的深度 和 高总是相等。
                        
        2.遍历：
            
            2.1 先序遍历 顺序为： 首先处理父节点，然后左节点，最后右节点
            2.2 中序遍历 顺序为： 首先处理左节点，然后父节点，最后右节点
            2.3 后序遍历 顺序为： 首先处理左节点，然后右节点，最后父节点                                                             
            
            其实就是父节点被处理的顺序。
            
            应用：文件树的遍历
            
        3.二叉树的实现 
        
            3.1 表达式树 (将一个中序表达式转换为后缀表达式。然后通过栈将后缀构建表达式树)
            3.2 查找二叉树 (提供一种平均以对数(log2 N)的时间复杂度查找方式)
                
                二叉树的描述：二叉树的所有操作平均是log2N的。
                
                3.2.1 insert操作：依靠compareTo(),递归的寻找合适的位置(遍历到当前节点为空时)，
                      创建节点，并将节点作为一个最新子树根节点返回并赋值给对应的父节点(递归操作)。
            
                3.2.2 remove操作：1.当需要删除节点具有一个子节点，把删除节点的子节点赋值给
                                    需要删除节点对应的父节点的子节点。
                                  2.当需要删除节点有两个子节点，获取到删除节点的右节点的最小节点的数据
                                        代替需要删除的数据，然后将代替节点的原节点删除(使用第一种方式递归删除)。
                
                3.2.3 findMin 、findMax 操作：从根节点向着左或右节点单向遍历，直到当前项的下一项为空时，
                                                当前项数据就是最小或最大值。                              
        4.AVL树(带有平衡条件的二叉查找树)
            
            4.1 描述：可能存在不平衡的输入或者输出时，insert 与 remove 
                        会将整棵树的结构趋向不平衡。所以在每次insert或者remove时，
                        都要检测一下树的平衡(由插入或删除的节点的父节点开始，
                        沿着返回路径节点一个个的检查，左节点和右节点的高度差<=1)。         
            4.2 操作：
            
                    4.2.1 insert
                    4.2.2 remove   
                    
        5.延伸树：将访问的节点推向第一个。
        
            
        6.树的遍历
           
            1.中序遍历
                递归的处理左子树，然后中间节点，最后右子树。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后中间节点，最后处理右子树。如果右子树有子节点，
                    重复上面的操作。
            2.后序遍历
                 递归的处理左子树，然后，最后中间节点。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后右子树，最后处理中间节点。如果右子树有子节点，
                    重复上面的操作。    
            
            3.前序遍历
            
        7.B树
            
            B树的特性：
            
                7.1.1 数据存储在树叶上。
                7.1.2 非树叶节点存储 M-1 个关键字来指引搜索的方向，关键字i是i+1中最小的关键字。
                7.1.3 树的根下的儿子数为2-M之间。（如M=5,儿子数在2-5之间）
                7.1.4 除根外，所有的非树叶节点的儿子数（多小片树叶）在 M/2 -- M之间。（如M=5,儿子数在3-5之间）
                7.1.5 所有的树叶都是同在一个深度，并且数目（一片树叶的数据数目）在 L/2 -- L之间。
                            
        
        8.将一些元素插入到树中，然后执行中序遍历。是一种以O（N log n）的排序。       
  
  三、散列
  
        1.定义：
            
            1.1 将一个元素散列到一个通过散列函数计算出的位置上。（计算的目标是关键字key）。
            
            1.2 散列函数：将输入的关键字计算出一个int数据，int表示该元素在散列表的位置。
            
                1.2.1 一个散列函数的实现：
                
                      一般关键字为字符串,以公式 k₁ = m₁  k₂ = 37 × k₁ + m₂  k₃ = 37 × k₂ + m₂ ....
                      其中K为暂时散列值, M为每个字符的 ASCII 或者 UNICODE 对应的编码值。
                      
                      代码：
                            public int getHash(String key){
                                
                                int hash = 0;
                                for(int i=0; i<key.length; i++){
                                    char c = key.charAt(i);
                                    hash = 37 * hash + c;
                                }
                                hash %= hashTable;
                                if(hash < 0){
                                    hash = hash + hashTable
                                }
                                return hash;
                            }
                                
  
        
        2. 分离链表法     
             
            2.1 描述：为散列表每个位置添加一个链表,如果链表的元素重复不添加。通过散列函数计算
                     出元素的对应为位置, 每次添加都放入到链表的表头。分离链表法的散列表的 
                     λ = 1(表元素除以表的大小)。假设链表的平均长度为λ,对于成功的查找的平均为
                     1 + ½ λ。λ的大小不影响分离链表的查找速度,链表的大小影响查找速度。如果
                     λ ≈ 1,就需要扩展散列表。
            
            2.2
               相关代码已实现。         
        
        3.线性探测
        
            3.1 描述：通过散列函数计算出关键资散列位置。使用方式f(i)=i,如位置被占用后,向当前位置向后移动一个位置
                     (以此类推,可以循环散列表),直到位置为空元素插入。一次成功的查找花费时间公式为
                     ½(1﹢1/(1-λ)),对于的插入或者不成功的查找(一直探测，直到为空元素)花费时间为
                     ½(1﹢1/(1-λ)²),实验数据表明插入或者不成功时,当λ=0.75，平均探测次数8。λ=0.9,
                     平均探测次数为50.λ=0.5,探测次数为2.5,而成功的查找只需要1.5次探测。(以上数据为平均值)
                     
            3.2 一次聚集问题：如果以一个位置的移动来解决冲突,会产生元素都聚集在一个一个区域的问题。
                
        4.平方探测
        
            4.1 描述：通过散列函数计算出关键字散列位置,使用方式f(i)=i²,如果位置被占用后，向下移动一个位置,
                     直到元素为空为止。当前位置为散列位置+i²。平方探测主要解决一次聚集问题。
        
            4.2  定理: 使用平方探测时,表的大小为素数,表的元素小于表大小一半(λ < 0.5),那么
                       散列表总能插入数据(不会发生位置冲突)
                                 
            4.3 实现: 注意删除中要进行懒删除,否则丢失向下查找的路径。所以用一个抽象
                      数据进行描述, 有属性element和isActive表示是否已经删除。当进行
                      表的扩容时,已经标为删除的元素不要迁移到新的散列表。
                      迁移的过程中需要重新迁移。        
        5.双散列
        
            5.1 描述：通过散列函数计算出关键字散列位置，如发生位置冲突，使用另外一个散列函数计算位置
                     使用公式 hash(x)=R -(x mod R),其中R为一个小于散列表大小的素数。计算出来的int
                     类型的数据是新的位置,如果表的大小素数是很小情况下第二次散列会出现位置冲突。
                     
            5.2 与平方探测的比较： 双散列发生位置冲突的概率更小,但是双散列计算比较长的关键字时,
                                会多一次的计算会影响效率。
                                
                                         
        6.再散列
            
         
        7.闪存散列代码（hashcode）
        
            在java的String对象的hashcode()中,hashcode计算后就会存储起来,
            第二次不用重新计算。由于String是不可改变,所以hashcode是有效的。
            一般有用于在散列的时候，不用再次计算hashcoe。或在扩容时,已经储存的
            key的散列代码已经被存储，再次散列不需要重新计算hashcde
            
            闪存散列代码实现：
                
                public final class String{
                    
                    private int hash = 0;
                    public int hashcode(){
                        if(hash != 0){
                            return hash;
                        }
                        for(int i=; i<length; i++){
                            hash = 31 * hash + (int)charAt(i);
                        }
                        return hash;
                    }                                                 
                }
        
        8. 布谷鸟散列
        
           8.1 描述：根据一个盒子选择问题的客观事实,当选择两个盒子的投放球时,比随机选择
                一个盒子投放球的盒子最大球球少。当可以选择两个随机的盒子,出现冲突的次数
                概率很小。当填充因子 λ < 0.5时,平均的查、增、删的时间复杂度为O(1)。
                当λ > 0.5 之后, 查、增、删的效率变得低下(多次的替换,甚至循环替换)。
                如果发生多次的替换,考虑使用新的散列函数再散列。如果λ接近0.5左右,考虑
                扩张表的大小。
                
           8.2 实现：代码实现已经完成
            
                散列函数: 定义一个散列函数接口,其中提供生成散列代码(hashcode)、散列函数
                        个数、生成新的散列函数。
                
                查找：循环使用散列函数生成hashcode,并且进行equlas()比较。
                
                插入：判断是否已经存在了,然后判断λ。之后循环的使用散列函数生成hashcoe,
                      选择一个合适位置插入。如未找到，随机选择一个散列函数生成的hashcode,
                      替换改位置的元素,被替换的元素重新选择一个散列函数,寻找适合位置。
                      每次发生替换,进行再散列。并记录替换的次数,当替换次数达到限定。
                      进行表的扩张。如未找到,重做以上步骤。
                      如果λ < 0.5,替换的动作很少发生。  
                
                删除：判断是否存在。如果存在,直接将引用赋值为null。
                
                再散列: 使用新的散列函数,将元素重新散列到一个新相同大小的散列表。
                
                
                
  五、优先队列(堆)
  
        5.1 描述：先进先出,但是优先权较高的可以优先出队。
        
        
        
        5.2 二叉堆 
                
             5.2.1堆的性质:
                
                 5.2.1-1 结构性质：由于堆是一颗完全二叉树,可以使用
                                  数组来实现(通过计算得出出子节点和父节点位置)。
                                  已知节点n的左子节点为2n,右子节点为2n+1。父节点为2/n。
                    
                 5.2.1-2 堆序性质：元素都是按一定的顺序。如所有的父节点都小于(大于)
                                  两个(一个)子节点
                    
             5.2.2 堆的基本操作：
                
                 5.2.2-1 插入(上滤)：在堆的最后创建一个新节点,用该节点位置算出父节点的位置，
                                    如果父节点的优先级低于新增节点,将父节点下拉到新增节
                                    点位置。如此循环,直到根节点。
                 
                 5.2.2-2 删除(下滤)：把根节点删除。删除堆的最后一个元素,并将它拷贝给根节点。
                                    然后算出根节点的子节点的位置，并把根节点和最高优先权子节点(
                                    左节点或右节点)比较。如果根节点优先权小于子节点,那么根节点下滤。
                                    如此循环，直到树叶。
                 
             5.2.3 堆的其他操作：
             
                 5.2.3-1 降低关键字值：以挺高优先权,首选破坏堆序性质,使得堆通过上滤进行调整。                 
                 5.2.3-2 增加关键字值：以降低优先权,首先破坏堆序性质,使得堆通过下滤进行调整。
                 5.2.3-3 删除：通过上滤或者下滤调整后,删除元素。                                          
        
             5.3.4
                
                5.3.4-1 构建堆：通过一组数组构建一个二叉堆,首先将数据按顺序录入二叉堆,然后
                                让最后两个节点(如果有)的优先级高的和其父节点比较,如果优先级比
                                父节点高,父节点下滤。然后再去根据优先级下滤下一个父节点。其中
                                构建一个二叉堆下滤的次数最多为这个二叉堆的节点高度和。
                                
                5.3.4-2 定理：包含2^(h+1)-1个节点、高度为h的理想二叉树节点高度和为:
                                2^(h+1)-1-(h+1)                
                
                
                        

                                                  数据结构笔记
  一、抽象的数据类型（ADT）

        1. ADT 是一组带有操作的对象集合，如表、树等。他们是一个数据集合的抽象。

  二、 表

        1.普通表

            1.1 add()、remove() 在前端操作是花费高昂的(O(n)),所有的数据都要向后（前）移动一位。
            1.2 findKth(i) 该操作花费为 O(1)

        2.链表

            2.1 add()、remove() 在前端操作是花费高昂的(O(1)),所有的数据只是交换一下前后的引用。（还有分配空间）
            2.2 findKth(i) 该操作花费wei O(n),该操作没有普通表的高效( 因为普通表的存储是连续的,地址及计算是O(1) )。

        3.Collcetion 接口

            3.1 是 java 对数据结构的实现的定义。表（ArrayList、linkedList）就是其中的一种定义。

            3.2 其中 Collection 接口扩展了 Iterator 接口 ,
                每一个Collection 都要提供Iterator的实现（提供该接口的迭代方式）。

            3.3 Collection的实现能否使用ForEach,需要实现Iterator。ForEach依赖Iterator.

       4.Iteraor 接口
       
            4.1 Iterator 提供三个接口定义：hasNext() , next() , remove()
            
                4.1.1 hasNext(): 判断是否有下一项,初始值为 0, 每次调用next()，会向下推进一位。
                4.1.2 next(): 获取当前项，并将当前的光标向下推进一位。(
                                注意：获取迭代器时，保存当前modCount,每次操作前都对比modCount和
                                      获取迭代器时的modCount，如果不相等，迭代器是非法的。抛出 ConcurrentModificationException )
                4.1.3 remove(): 迭代器可以保存当前项。对当前项进行删除是很高效的。
       
  
  二、栈(Stack)     
  
        1. 定义：限制了插入和刪除只能在一个位置进行操作，也就是表的末端(栈顶)。操作也只有两种，
                 push(压栈、入栈) 和 pop(弹栈、出栈)。top 表示一个指针，永远指向栈顶。
                 
        2.特性：先进后出、后进先出
        
        3.实现：可以使用表的ADT(ArrayList 或 LinkedLilst)。因为只有push 和 pop。并在表的末端操作
                所以相对简单。并且每次 push 、 pop 操作都是常数(O(1))时间。   
                
        4.应用
        
            4.1 编译器的语法检验
            
                具体步骤：
                
                        对文本的每个字符遍历，如遇到 ( {  [  / 将改字符压栈，如果出现封闭符号，抛错。
                        遇到/,判断栈顶元素是否对应。如果不抛错。否则弹栈。如果文件读到结尾，
                        栈中还有元素抛错。
                        
            4.2 简单的计算器      
                
                    4.2.1 后缀表达式计算
                    
                          (2*3+5)/6 --> 23*5+6/
                          2*5+22-10/12 --> 25*22+10/12-
                          
                          算法：
                                2 5 * 22 + 10 / 12 -
                                将数据读入：2 5  stack --> 2 5
                                    遇到 * ，弹栈 2*5 = 10 压栈  stack --> 10
                                将数据读入：22   stack --> 10 22
                                    遇到 + ，弹栈 10+22 = 32 压栈  stack --> 32
                                        
                                        以此类推....
                                        
                    4.2.2 中缀表达式转换为后缀表达式                                  
                     
                           中缀 --> 后缀
                           2*5+22-10/12 --> 25*22+10/12-
                           
            4.3 程序运行方法调用栈使用
                
              4.3.1 当主调进程有新的方法调用时,防止新方法的变量覆盖了主调进程的变量,将主调进程的
                     变量和地址存放栈里面。当新方法执行后，获取到返回地址，并恢复主调进程的变量。           
  
  二、树
  
        1.定义：
            
            1.1 树右一个根节点和N个节点，一条边连接子树或子节点。有N-1条边。如果节点下没有子节点，
                    该节点称为树叶。具有具有相同父节点的节点称为兄弟节点。
                
            1.2 从一个节点到任意一个节点的只有一条路线，这条路线的称为路径。
            
            1.3 深度和高的区别 ：
                    深度是根节点到节点的路径长度。
                    高是目标节点到树叶最长路径。
                        注意：一棵树的深度 和 高总是相等。
                        
        2.遍历：
            
            2.1 先序遍历 顺序为： 首先处理父节点，然后左节点，最后右节点
            2.2 中序遍历 顺序为： 首先处理左节点，然后父节点，最后右节点
            2.3 后序遍历 顺序为： 首先处理左节点，然后右节点，最后父节点                                                             
            
            其实就是父节点被处理的顺序。
            
            应用：文件树的遍历
            
        3.二叉树的实现 
        
            3.1 表达式树 (将一个中序表达式转换为后缀表达式。然后通过栈将后缀构建表达式树)
            3.2 查找二叉树 (提供一种平均以对数(log2 N)的时间复杂度查找方式)
                
                二叉树的描述：二叉树的所有操作平均是log2N的。
                
                3.2.1 insert操作：依靠compareTo(),递归的寻找合适的位置(遍历到当前节点为空时)，
                      创建节点，并将节点作为一个最新子树根节点返回并赋值给对应的父节点(递归操作)。
            
                3.2.2 remove操作：1.当需要删除节点具有一个子节点，把删除节点的子节点赋值给
                                    需要删除节点对应的父节点的子节点。
                                  2.当需要删除节点有两个子节点，获取到删除节点的右节点的最小节点的数据
                                        代替需要删除的数据，然后将代替节点的原节点删除(使用第一种方式递归删除)。
                
                3.2.3 findMin 、findMax 操作：从根节点向着左或右节点单向遍历，直到当前项的下一项为空时，
                                                当前项数据就是最小或最大值。                              
        4.AVL树(带有平衡条件的二叉查找树)
            
            4.1 描述：可能存在不平衡的输入或者输出时，insert 与 remove 
                        会将整棵树的结构趋向不平衡。所以在每次insert或者remove时，
                        都要检测一下树的平衡(由插入或删除的节点的父节点开始，
                        沿着返回路径节点一个个的检查，左节点和右节点的高度差<=1)。         
            4.2 操作：
            
                    4.2.1 insert
                    4.2.2 remove   
                    
        5.延伸树：将访问的节点推向第一个。
        
            
        6.树的遍历
           
            1.中序遍历
                递归的处理左子树，然后中间节点，最后右子树。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后中间节点，最后处理右子树。如果右子树有子节点，
                    重复上面的操作。
            2.后序遍历
                 递归的处理左子树，然后，最后中间节点。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后右子树，最后处理中间节点。如果右子树有子节点，
                    重复上面的操作。    
            
            3.前序遍历
            
        7.B树
            
            B树的特性：
            
                7.1.1 数据存储在树叶上。
                7.1.2 非树叶节点存储 M-1 个关键字来指引搜索的方向，关键字i是i+1中最小的关键字。
                7.1.3 树的根下的儿子数为2-M之间。（如M=5,儿子数在2-5之间）
                7.1.4 除根外，所有的非树叶节点的儿子数（多小片树叶）在 M/2 -- M之间。（如M=5,儿子数在3-5之间）
                7.1.5 所有的树叶都是同在一个深度，并且数目（一片树叶的数据数目）在 L/2 -- L之间。
                            
        
        8.将一些元素插入到树中，然后执行中序遍历。是一种以O（N log n）的排序。       
  
  三、散列
  
        1.定义：
            
            1.1 将一个元素散列到一个通过散列函数计算出的位置上。（计算的目标是关键字key）。
            
            1.2 散列函数：将输入的关键字计算出一个int数据，int表示该元素在散列表的位置。
            
                1.2.1 一个散列函数的实现：
                
                      一般关键字为字符串,以公式 k₁ = m₁  k₂ = 37 × k₁ + m₂  k₃ = 37 × k₂ + m₂ ....
                      其中K为暂时散列值, M为每个字符的 ASCII 或者 UNICODE 对应的编码值。
                      
                      代码：
                            public int getHash(String key){
                                
                                int hash = 0;
                                for(int i=0; i<key.length; i++){
                                    char c = key.charAt(i);
                                    hash = 37 * hash + c;
                                }
                                hash %= hashTable;
                                if(hash < 0){
                                    hash = hash + hashTable
                                }
                                return hash;
                            }
                                
  
        
        2. 分离链表法     
             
            2.1 描述：为散列表每个位置添加一个链表,如果链表的元素重复不添加。通过散列函数计算
                     出元素的对应为位置, 每次添加都放入到链表的表头。分离链表法的散列表的 
                     λ = 1(表元素除以表的大小)。假设链表的平均长度为λ,对于成功的查找的平均为
                     1 + ½ λ。λ的大小不影响分离链表的查找速度,链表的大小影响查找速度。如果
                     λ ≈ 1,就需要扩展散列表。
            
            2.2
               相关代码已实现。         
        
        3.线性探测
        
            3.1 描述：通过散列函数计算出关键资散列位置。使用方式f(i)=i,如位置被占用后,向当前位置向后移动一个位置
                     (以此类推,可以循环散列表),直到位置为空元素插入。一次成功的查找花费时间公式为
                     ½(1﹢1/(1-λ)),对于的插入或者不成功的查找(一直探测，直到为空元素)花费时间为
                     ½(1﹢1/(1-λ)²),实验数据表明插入或者不成功时,当λ=0.75，平均探测次数8。λ=0.9,
                     平均探测次数为50.λ=0.5,探测次数为2.5,而成功的查找只需要1.5次探测。(以上数据为平均值)
                     
            3.2 一次聚集问题：如果以一个位置的移动来解决冲突,会产生元素都聚集在一个一个区域的问题。
                
        4.平方探测
        
            4.1 描述：通过散列函数计算出关键字散列位置,使用方式f(i)=i²,如果位置被占用后，向下移动一个位置,
                     直到元素为空为止。当前位置为散列位置+i²。平方探测主要解决一次聚集问题。
        
            4.2  定理: 使用平方探测时,表的大小为素数,表的元素小于表大小一半(λ < 0.5),那么
                       散列表总能插入数据(不会发生位置冲突)
                                 
                     
        5.双散列
        
            5.1 描述：通过散列函数计算出关键字散列位置，如发生位置冲突，使用另外一个散列函数计算位置
                     使用公式 hash(x)=R -(x mod R),其中R为一个小于散列表大小的素数。计算出来的int
                     类型的数据是新的位置,如果表的大小素数是很小情况下第二次散列会出现位置冲突。
                     
            5.2 与平方探测的比较： 双散列发生位置冲突的概率更小,但是双散列计算比较长的关键字时,
                                会多一次的计算会影响效率。
                                
                                         
        6.再散列
            
                                                         
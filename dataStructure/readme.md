
                                                  数据结构笔记
  一、抽象的数据类型（ADT）

        1. ADT 是一组带有操作的对象集合，如表、树等。他们是一个数据集合的抽象。

  二、 表

        1.普通表

            1.1 add()、remove() 在前端操作是花费高昂的(O(n)),所有的数据都要向后（前）移动一位。
            1.2 findKth(i) 该操作花费为 O(1)

        2.链表

            2.1 add()、remove() 在前端操作是花费高昂的(O(1)),所有的数据只是交换一下前后的引用。（还有分配空间）
            2.2 findKth(i) 该操作花费wei O(n),该操作没有普通表的高效( 因为普通表的存储是连续的,地址及计算是O(1) )。

        3.Collcetion 接口

            3.1 是 java 对数据结构的实现的定义。表（ArrayList、linkedList）就是其中的一种定义。

            3.2 其中 Collection 接口扩展了 Iterator 接口 ,
                每一个Collection 都要提供Iterator的实现（提供该接口的迭代方式）。

            3.3 Collection的实现能否使用ForEach,需要实现Iterator。ForEach依赖Iterator.

       4.Iteraor 接口
       
            4.1 Iterator 提供三个接口定义：hasNext() , next() , remove()
            
                4.1.1 hasNext(): 判断是否有下一项,初始值为 0, 每次调用next()，会向下推进一位。
                4.1.2 next(): 获取当前项，并将当前的光标向下推进一位。(
                                注意：获取迭代器时，保存当前modCount,每次操作前都对比modCount和
                                      获取迭代器时的modCount，如果不相等，迭代器是非法的。抛出 ConcurrentModificationException )
                4.1.3 remove(): 迭代器可以保存当前项。对当前项进行删除是很高效的。
       
  
  二、栈(Stack)     
  
        1. 定义：限制了插入和刪除只能在一个位置进行操作，也就是表的末端(栈顶)。操作也只有两种，
                 push(压栈、入栈) 和 pop(弹栈、出栈)。top 表示一个指针，永远指向栈顶。
                 
        2.特性：先进后出、后进先出
        
        3.实现：可以使用表的ADT(ArrayList 或 LinkedLilst)。因为只有push 和 pop。并在表的末端操作
                所以相对简单。并且每次 push 、 pop 操作都是常数(O(1))时间。   
                
        4.应用
        
            4.1 编译器的语法检验
            
                具体步骤：
                
                        对文本的每个字符遍历，如遇到 ( {  [  / 将改字符压栈，如果出现封闭符号，抛错。
                        遇到/,判断栈顶元素是否对应。如果不抛错。否则弹栈。如果文件读到结尾，
                        栈中还有元素抛错。
                        
            4.2 简单的计算器      
                
                    4.2.1 后缀表达式计算
                    
                          (2*3+5)/6 --> 23*5+6/
                          2*5+22-10/12 --> 25*22+10/12-
                          
                          算法：
                                2 5 * 22 + 10 / 12 -
                                将数据读入：2 5  stack --> 2 5
                                    遇到 * ，弹栈 2*5 = 10 压栈  stack --> 10
                                将数据读入：22   stack --> 10 22
                                    遇到 + ，弹栈 10+22 = 32 压栈  stack --> 32
                                        
                                        以此类推....
                                        
                    4.2.2 中缀表达式转换为后缀表达式                                  
                     
                           中缀 --> 后缀
                           2*5+22-10/12 --> 25*22+10/12-
                           
            4.3 程序运行方法调用栈使用
                
              4.3.1 当主调进程有新的方法调用时,防止新方法的变量覆盖了主调进程的变量,将主调进程的
                     变量和地址存放栈里面。当新方法执行后，获取到返回地址，并恢复主调进程的变量。           
  
  二、树
  
        1.定义：
            
            1.1 树右一个根节点和N个节点，一条边连接子树或子节点。有N-1条边。如果节点下没有子节点，
                    该节点称为树叶。具有具有相同父节点的节点称为兄弟节点。
                
            1.2 从一个节点到任意一个节点的只有一条路线，这条路线的称为路径。
            
            1.3 深度和高的区别 ：
                    深度是根节点到节点的路径长度。
                    高是目标节点到树叶最长路径。
                        注意：一棵树的深度 和 高总是相等。
                        
        2.遍历：
            
            2.1 先序遍历 顺序为： 首先处理父节点，然后左节点，最后右节点
            2.2 中序遍历 顺序为： 首先处理左节点，然后父节点，最后右节点
            2.3 后序遍历 顺序为： 首先处理左节点，然后右节点，最后父节点                                                             
            
            其实就是父节点被处理的顺序。
            
            应用：文件树的遍历
            
        3.二叉树的实现 
        
            3.1 表达式树 (将一个中序表达式转换为后缀表达式。然后通过栈将后缀构建表达式树)
            3.2 查找二叉树 (提供一种平均以对数(log2 N)的时间复杂度查找方式)
                
                二叉树的描述：二叉树的所有操作平均是log2N的。
                
                3.2.1 insert操作：依靠compareTo(),递归的寻找合适的位置(遍历到当前节点为空时)，
                      创建节点，并将节点作为一个最新子树根节点返回并赋值给对应的父节点(递归操作)。
            
                3.2.2 remove操作：1.当需要删除节点具有一个子节点，把删除节点的子节点赋值给
                                    需要删除节点对应的父节点的子节点。
                                  2.当需要删除节点有两个子节点，获取到删除节点的右节点的最小节点的数据
                                        代替需要删除的数据，然后将代替节点的原节点删除(使用第一种方式递归删除)。
                
                3.2.3 findMin 、findMax 操作：从根节点向着左或右节点单向遍历，直到当前项的下一项为空时，
                                                当前项数据就是最小或最大值。                              
        4.AVL树(带有平衡条件的二叉查找树)
            
            4.1 描述：可能存在不平衡的输入或者输出时，insert 与 remove 
                        会将整棵树的结构趋向不平衡。所以在每次insert或者remove时，
                        都要检测一下树的平衡(由插入或删除的节点的父节点开始，
                        沿着返回路径节点一个个的检查，左节点和右节点的高度差<=1)。         
            4.2 操作：
            
                    4.2.1 insert
                    4.2.2 remove   
                    
        5.延伸树：将访问的节点推向第一个。
        
            
        6.树的遍历
           
            1.中序遍历
                递归的处理左子树，然后中间节点，最后右子树。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后中间节点，最后处理右子树。如果右子树有子节点，
                    重复上面的操作。
            2.后序遍历
                 递归的处理左子树，然后，最后中间节点。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后右子树，最后处理中间节点。如果右子树有子节点，
                    重复上面的操作。    
            
            3.前序遍历
            
        7.B树
            
            B树的特性：
            
                7.1.1 数据存储在树叶上。
                7.1.2 非树叶节点存储 M-1 个关键字来指引搜索的方向，关键字i是i+1中最小的关键字。
                7.1.3 树的根下的儿子数为2-M之间。（如M=5,儿子数在2-5之间）
                7.1.4 除根外，所有的非树叶节点的儿子数（多小片树叶）在 M/2 -- M之间。（如M=5,儿子数在3-5之间）
                7.1.5 所有的树叶都是同在一个深度，并且数目（一片树叶的数据数目）在 L/2 -- L之间。
                            
               
                            
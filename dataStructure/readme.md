
                                                  数据结构笔记
  一、抽象的数据类型（ADT）

        1. ADT 是一组带有操作的对象集合，如表、树等。他们是一个数据集合的抽象。

  二、 表

        1.普通表

            1.1 add()、remove() 在前端操作是花费高昂的(O(n)),所有的数据都要向后（前）移动一位。
            1.2 findKth(i) 该操作花费为 O(1)

        2.链表

            2.1 add()、remove() 在前端操作是花费高昂的(O(1)),所有的数据只是交换一下前后的引用。（还有分配空间）
            2.2 findKth(i) 该操作花费wei O(n),该操作没有普通表的高效( 因为普通表的存储是连续的,地址及计算是O(1) )。

        3.Collcetion 接口

            3.1 是 java 对数据结构的实现的定义。表（ArrayList、linkedList）就是其中的一种定义。

            3.2 其中 Collection 接口扩展了 Iterator 接口 ,
                每一个Collection 都要提供Iterator的实现（提供该接口的迭代方式）。

            3.3 Collection的实现能否使用ForEach,需要实现Iterator。ForEach依赖Iterator.

       4.Iteraor 接口
       
            4.1 Iterator 提供三个接口定义：hasNext() , next() , remove()
            
                4.1.1 hasNext(): 判断是否有下一项,初始值为 0, 每次调用next()，会向下推进一位。
                4.1.2 next(): 获取当前项，并将当前的光标向下推进一位。(
                                注意：获取迭代器时，保存当前modCount,每次操作前都对比modCount和
                                      获取迭代器时的modCount，如果不相等，迭代器是非法的。抛出 ConcurrentModificationException )
                4.1.3 remove(): 迭代器可以保存当前项。对当前项进行删除是很高效的。
       
  
  二、栈(Stack)     
  
        1. 定义：限制了插入和刪除只能在一个位置进行操作，也就是表的末端(栈顶)。操作也只有两种，
                 push(压栈、入栈) 和 pop(弹栈、出栈)。top 表示一个指针，永远指向栈顶。
                 
        2.特性：先进后出、后进先出
        
        3.实现：可以使用表的ADT(ArrayList 或 LinkedLilst)。因为只有push 和 pop。并在表的末端操作
                所以相对简单。并且每次 push 、 pop 操作都是常数(O(1))时间。   
                
        4.应用
        
            4.1 编译器的语法检验
            
                具体步骤：
                
                        对文本的每个字符遍历，如遇到 ( {  [  / 将改字符压栈，如果出现封闭符号，抛错。
                        遇到/,判断栈顶元素是否对应。如果不抛错。否则弹栈。如果文件读到结尾，
                        栈中还有元素抛错。
                        
            4.2 简单的计算器      
                
                    4.2.1 后缀表达式计算
                    
                          (2*3+5)/6 --> 23*5+6/
                          2*5+22-10/12 --> 25*22+10/12-
                          
                          算法：
                                2 5 * 22 + 10 / 12 -
                                将数据读入：2 5  stack --> 2 5
                                    遇到 * ，弹栈 2*5 = 10 压栈  stack --> 10
                                将数据读入：22   stack --> 10 22
                                    遇到 + ，弹栈 10+22 = 32 压栈  stack --> 32
                                        
                                        以此类推....
                                        
                    4.2.2 中缀表达式转换为后缀表达式                                  
                     
                           中缀 --> 后缀
                           2*5+22-10/12 --> 25*22+10/12-
                           
            4.3 程序运行方法调用栈使用
                
              4.3.1 当主调进程有新的方法调用时,防止新方法的变量覆盖了主调进程的变量,将主调进程的
                     变量和地址存放栈里面。当新方法执行后，获取到返回地址，并恢复主调进程的变量。           
  
  二、树
  
        1.定义：
            
            1.1 树右一个根节点和N个节点，一条边连接子树或子节点。有N-1条边。如果节点下没有子节点，
                    该节点称为树叶。具有具有相同父节点的节点称为兄弟节点。
                
            1.2 从一个节点到任意一个节点的只有一条路线，这条路线的称为路径。
            
            1.3 深度和高的区别 ：
                    深度是根节点到节点的路径长度。
                    高是目标节点到树叶最长路径。
                        注意：一棵树的深度 和 高总是相等。
                        
        2.遍历：
            
            2.1 先序遍历 顺序为： 首先处理父节点，然后左节点，最后右节点
            2.2 中序遍历 顺序为： 首先处理左节点，然后父节点，最后右节点
            2.3 后序遍历 顺序为： 首先处理左节点，然后右节点，最后父节点                                                             
            
            其实就是父节点被处理的顺序。
            
            应用：文件树的遍历
            
        3.二叉树的实现 
        
            3.1 表达式树 (将一个中序表达式转换为后缀表达式。然后通过栈将后缀构建表达式树)
            3.2 查找二叉树 (提供一种平均以对数(log2 N)的时间复杂度查找方式)
            
        4.AVL树(带有平衡条件的二叉查找树)
            
            4.1           
                

                                                  数据结构笔记
  一、抽象的数据类型（ADT）

        1. ADT 是一组带有操作的对象集合，如表、树等。他们是一个数据集合的抽象。

  二、 表

        1.普通表

            1.1 add()、remove() 在前端操作是花费高昂的(O(n)),所有的数据都要向后（前）移动一位。
            1.2 findKth(i) 该操作花费为 O(1)

        2.链表

            2.1 add()、remove() 在前端操作是花费高昂的(O(1)),所有的数据只是交换一下前后的引用。（还有分配空间）
            2.2 findKth(i) 该操作花费wei O(n),该操作没有普通表的高效( 因为普通表的存储是连续的,地址及计算是O(1) )。

        3.Collcetion 接口

            3.1 是 java 对数据结构的实现的定义。表（ArrayList、linkedList）就是其中的一种定义。

            3.2 其中 Collection 接口扩展了 Iterator 接口 ,
                每一个Collection 都要提供Iterator的实现（提供该接口的迭代方式）。

            3.3 Collection的实现能否使用ForEach,需要实现Iterator。ForEach依赖Iterator.

       4.Iteraor 接口
       
            4.1 Iterator 提供三个接口定义：hasNext() , next() , remove()
            
                4.1.1 hasNext(): 判断是否有下一项,初始值为 0, 每次调用next()，会向下推进一位。
                4.1.2 next(): 获取当前项，并将当前的光标向下推进一位。(
                                注意：获取迭代器时，保存当前modCount,每次操作前都对比modCount和
                                      获取迭代器时的modCount，如果不相等，迭代器是非法的。抛出 ConcurrentModificationException )
                4.1.3 remove(): 迭代器可以保存当前项。对当前项进行删除是很高效的。
       
  
  二、栈(Stack)     
  
        1. 定义：限制了插入和刪除只能在一个位置进行操作，也就是表的末端(栈顶)。操作也只有两种，
                 push(压栈、入栈) 和 pop(弹栈、出栈)。top 表示一个指针，永远指向栈顶。
                 
        2.特性：先进后出、后进先出
        
        3.实现：可以使用表的ADT(ArrayList 或 LinkedLilst)。因为只有push 和 pop。并在表的末端操作
                所以相对简单。并且每次 push 、 pop 操作都是常数(O(1))时间。   
                
        4.应用
        
            4.1 编译器的语法检验
            
                具体步骤：
                
                        对文本的每个字符遍历，如遇到 ( {  [  / 将改字符压栈，如果出现封闭符号，抛错。
                        遇到/,判断栈顶元素是否对应。如果不抛错。否则弹栈。如果文件读到结尾，
                        栈中还有元素抛错。
                        
            4.2 简单的计算器      
                
                    4.2.1 后缀表达式计算
                    
                          (2*3+5)/6 --> 23*5+6/
                          2*5+22-10/12 --> 25*22+10/12-
                          
                          算法：
                                2 5 * 22 + 10 / 12 -
                                将数据读入：2 5  stack --> 2 5
                                    遇到 * ，弹栈 2*5 = 10 压栈  stack --> 10
                                将数据读入：22   stack --> 10 22
                                    遇到 + ，弹栈 10+22 = 32 压栈  stack --> 32
                                        
                                        以此类推....
                                        
                    4.2.2 中缀表达式转换为后缀表达式                                  
                     
                           中缀 --> 后缀
                           2*5+22-10/12 --> 25*22+10/12-
                           
            4.3 程序运行方法调用栈使用
                
              4.3.1 当主调进程有新的方法调用时,防止新方法的变量覆盖了主调进程的变量,将主调进程的
                     变量和地址存放栈里面。当新方法执行后，获取到返回地址，并恢复主调进程的变量。           
  
  二、树
  
        1.定义：
            
            1.1 树右一个根节点和N个节点，一条边连接子树或子节点。有N-1条边。如果节点下没有子节点，
                    该节点称为树叶。具有具有相同父节点的节点称为兄弟节点。
                
            1.2 从一个节点到任意一个节点的只有一条路线，这条路线的称为路径。
            
            1.3 深度和高的区别 ：
                    深度是根节点到节点的路径长度。
                    高是目标节点到树叶最长路径。
                        注意：一棵树的深度 和 高总是相等。
                        
        2.遍历：
            
            2.1 先序遍历 顺序为： 首先处理父节点，然后左节点，最后右节点
            2.2 中序遍历 顺序为： 首先处理左节点，然后父节点，最后右节点
            2.3 后序遍历 顺序为： 首先处理左节点，然后右节点，最后父节点                                                             
            
            其实就是父节点被处理的顺序。
            
            应用：文件树的遍历
            
        3.二叉树的实现 
        
            3.1 表达式树 (将一个中序表达式转换为后缀表达式。然后通过栈将后缀构建表达式树)
            3.2 查找二叉树 (提供一种平均以对数(log2 N)的时间复杂度查找方式)
                
                二叉树的描述：二叉树的所有操作平均是log2N的。
                
                3.2.1 insert操作：依靠compareTo(),递归的寻找合适的位置(遍历到当前节点为空时)，
                      创建节点，并将节点作为一个最新子树根节点返回并赋值给对应的父节点(递归操作)。
            
                3.2.2 remove操作：1.当需要删除节点具有一个子节点，把删除节点的子节点赋值给
                                    需要删除节点对应的父节点的子节点。
                                  2.当需要删除节点有两个子节点，获取到删除节点的右节点的最小节点的数据
                                        代替需要删除的数据，然后将代替节点的原节点删除(使用第一种方式递归删除)。
                
                3.2.3 findMin 、findMax 操作：从根节点向着左或右节点单向遍历，直到当前项的下一项为空时，
                                                当前项数据就是最小或最大值。                              
        4.AVL树(带有平衡条件的二叉查找树)
            
            4.1 描述：可能存在不平衡的输入或者输出时，insert 与 remove 
                        会将整棵树的结构趋向不平衡。所以在每次insert或者remove时，
                        都要检测一下树的平衡(由插入或删除的节点的父节点开始，
                        沿着返回路径节点一个个的检查，左节点和右节点的高度差<=1)。         
            4.2 操作：
            
                    4.2.1 insert
                    4.2.2 remove   
                    
        5.延伸树：将访问的节点推向第一个。
        
            
        6.树的遍历
           
            1.中序遍历
                递归的处理左子树，然后中间节点，最后右子树。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后中间节点，最后处理右子树。如果右子树有子节点，
                    重复上面的操作。
            2.后序遍历
                 递归的处理左子树，然后，最后中间节点。递归的进程是，首先递归遍历
                    到最左的树叶节点，然后右子树，最后处理中间节点。如果右子树有子节点，
                    重复上面的操作。    
            
            3.前序遍历
            
        7.B树
            
            B树的特性：
            
                7.1.1 数据存储在树叶上。
                7.1.2 非树叶节点存储 M-1 个关键字来指引搜索的方向，关键字i是i+1中最小的关键字。
                7.1.3 树的根下的儿子数为2-M之间。（如M=5,儿子数在2-5之间）
                7.1.4 除根外，所有的非树叶节点的儿子数（多小片树叶）在 M/2 -- M之间。（如M=5,儿子数在3-5之间）
                7.1.5 所有的树叶都是同在一个深度，并且数目（一片树叶的数据数目）在 L/2 -- L之间。
                            
        
        8.将一些元素插入到树中，然后执行中序遍历。是一种以O（N log n）的排序。       
  
  三、散列
  
        1.定义：
            
            1.1 将一个元素散列到一个通过散列函数计算出的位置上。（计算的目标是关键字key）。
            
            1.2 散列函数：将输入的关键字计算出一个int数据，int表示该元素在散列表的位置。
            
                1.2.1 一个散列函数的实现：
                
                      一般关键字为字符串,以公式 k₁ = m₁  k₂ = 37 × k₁ + m₂  k₃ = 37 × k₂ + m₂ ....
                      其中K为暂时散列值, M为每个字符的 ASCII 或者 UNICODE 对应的编码值。
                      
                      代码：
                            public int getHash(String key){
                                
                                int hash = 0;
                                for(int i=0; i<key.length; i++){
                                    char c = key.charAt(i);
                                    hash = 37 * hash + c;
                                }
                                hash %= hashTable;
                                if(hash < 0){
                                    hash = hash + hashTable
                                }
                                return hash;
                            }
                                
  
        
        2. 分离链表法     
             
            2.1 描述：为散列表每个位置添加一个链表,如果链表的元素重复不添加。通过散列函数计算
                     出元素的对应为位置, 每次添加都放入到链表的表头。分离链表法的散列表的 
                     λ = 1(表元素除以表的大小)。假设链表的平均长度为λ,对于成功的查找的平均为
                     1 + ½ λ。λ的大小不影响分离链表的查找速度,链表的大小影响查找速度。如果
                     λ ≈ 1,就需要扩展散列表。
            
            2.2
               相关代码已实现。         
        
        3.线性探测
        
            3.1 描述：通过散列函数计算出关键资散列位置。使用方式f(i)=i,如位置被占用后,向当前位置向后移动一个位置
                     (以此类推,可以循环散列表),直到位置为空元素插入。一次成功的查找花费时间公式为
                     ½(1﹢1/(1-λ)),对于的插入或者不成功的查找(一直探测，直到为空元素)花费时间为
                     ½(1﹢1/(1-λ)²),实验数据表明插入或者不成功时,当λ=0.75，平均探测次数8。λ=0.9,
                     平均探测次数为50.λ=0.5,探测次数为2.5,而成功的查找只需要1.5次探测。(以上数据为平均值)
                     
            3.2 一次聚集问题：如果以一个位置的移动来解决冲突,会产生元素都聚集在一个一个区域的问题。
                
        4.平方探测
        
            4.1 描述：通过散列函数计算出关键字散列位置,使用方式f(i)=i²,如果位置被占用后，向下移动一个位置,
                     直到元素为空为止。当前位置为散列位置+i²。平方探测主要解决一次聚集问题。
        
            4.2  定理: 使用平方探测时,表的大小为素数,表的元素小于表大小一半(λ < 0.5),那么
                       散列表总能插入数据(不会发生位置冲突)
                                 
            4.3 实现: 注意删除中要进行懒删除,否则丢失向下查找的路径。所以用一个抽象
                      数据进行描述, 有属性element和isActive表示是否已经删除。当进行
                      表的扩容时,已经标为删除的元素不要迁移到新的散列表。
                      迁移的过程中需要重新迁移。        
        5.双散列
        
            5.1 描述：通过散列函数计算出关键字散列位置，如发生位置冲突，使用另外一个散列函数计算位置
                     使用公式 hash(x)=R -(x mod R),其中R为一个小于散列表大小的素数。计算出来的int
                     类型的数据是新的位置,如果表的大小素数是很小情况下第二次散列会出现位置冲突。
                     
            5.2 与平方探测的比较： 双散列发生位置冲突的概率更小,但是双散列计算比较长的关键字时,
                                会多一次的计算会影响效率。
                                
                                         
        6.再散列
            
         
        7.闪存散列代码（hashcode）
        
            在java的String对象的hashcode()中,hashcode计算后就会存储起来,
            第二次不用重新计算。由于String是不可改变,所以hashcode是有效的。
            一般有用于在散列的时候，不用再次计算hashcoe。或在扩容时,已经储存的
            key的散列代码已经被存储，再次散列不需要重新计算hashcde
            
            闪存散列代码实现：
                
                public final class String{
                    
                    private int hash = 0;
                    public int hashcode(){
                        if(hash != 0){
                            return hash;
                        }
                        for(int i=; i<length; i++){
                            hash = 31 * hash + (int)charAt(i);
                        }
                        return hash;
                    }                                                 
                }
        
        8. 布谷鸟散列
        
           8.1 描述：根据一个盒子选择问题的客观事实,当选择两个盒子的投放球时,比随机选择
                一个盒子投放球的盒子最大球球少。当可以选择两个随机的盒子,出现冲突的次数
                概率很小。当填充因子 λ < 0.5时,平均的查、增、删的时间复杂度为O(1)。
                当λ > 0.5 之后, 查、增、删的效率变得低下(多次的替换,甚至循环替换)。
                如果发生多次的替换,考虑使用新的散列函数再散列。如果λ接近0.5左右,考虑
                扩张表的大小。
                
           8.2 实现：代码实现已经完成
            
                散列函数: 定义一个散列函数接口,其中提供生成散列代码(hashcode)、散列函数
                        个数、生成新的散列函数。
                
                查找：循环使用散列函数生成hashcode,并且进行equlas()比较。
                
                插入：判断是否已经存在了,然后判断λ。之后循环的使用散列函数生成hashcoe,
                      选择一个合适位置插入。如未找到，随机选择一个散列函数生成的hashcode,
                      替换改位置的元素,被替换的元素重新选择一个散列函数,寻找适合位置。
                      每次发生替换,进行再散列。并记录替换的次数,当替换次数达到限定。
                      进行表的扩张。如未找到,重做以上步骤。
                      如果λ < 0.5,替换的动作很少发生。  
                
                删除：判断是否存在。如果存在,直接将引用赋值为null。
                
                再散列: 使用新的散列函数,将元素重新散列到一个新相同大小的散列表。
                
                
                
  五、优先队列(堆)
  
        5.1 描述：先进先出,但是优先权较高的可以优先出队。
        
        
        
        5.2 二叉堆 
                
             5.2.1堆的性质:
                
                 5.2.1-1 结构性质：由于堆是一颗完全二叉树,可以使用
                                  数组来实现(通过计算得出出子节点和父节点位置)。
                                  已知节点n的左子节点为2n,右子节点为2n+1。父节点为2/n。
                    
                 5.2.1-2 堆序性质：元素都是按一定的顺序。如所有的父节点都小于(大于)
                                  两个(一个)子节点
                    
             5.2.2 堆的基本操作：
                
                 5.2.2-1 插入(上滤)：在堆的最后创建一个新节点,用该节点位置算出父节点的位置，
                                    如果父节点的优先级低于新增节点,将父节点下拉到新增节
                                    点位置。如此循环,直到根节点。
                                    
                                    时间复杂度：最坏O(log n) 平均常数
                 
                 5.2.2-2 删除(下滤)：把根节点删除。删除堆的最后一个元素,并将它拷贝给根节点。
                                    然后算出根节点的子节点的位置，并把根节点和最高优先权子节点(
                                    左节点或右节点)比较。如果根节点优先权小于子节点,那么根节点下滤。
                                    如此循环，直到树叶。
                                    
                                    时间复杂度：最坏O(log n) 平均O(log n)
                 
             5.2.3 堆的其他操作：
             
                 5.2.3-1 降低关键字值：以挺高优先权,首选破坏堆序性质,使得堆通过上滤进行调整。                 
                 5.2.3-2 增加关键字值：以降低优先权,首先破坏堆序性质,使得堆通过下滤进行调整。
                 5.2.3-3 删除：通过上滤或者下滤调整后,删除元素。                                          
        
             5.2.4
                
                5.2.4-1 构建堆：通过一组数组构建一个二叉堆,首先将数据按顺序录入二叉堆,然后
                                让最后两个节点(如果有)的优先级高的和其父节点比较,如果优先级比
                                父节点高,父节点下滤。然后再去根据优先级下滤下一个父节点。其中
                                构建一个二叉堆下滤的次数最多为这个二叉堆的节点高度和。
                                
                                时间复杂度：平均O(n)
                                
                5.2.4-2 定理：包含2^(h+1)-1个节点、高度为h的理想二叉树节点高度和为:
                                2^(h+1)-1-(h+1)                
                
        
        5.3 d-堆
        
            5.3.1-1 描述：d堆是二叉堆的一种扩展,二叉堆的只有两个子节点,d-堆有d个子节点。d-堆的deleteMin
                         操作比二叉堆更耗时。树的深度变短了,但是下滤过程中查找较小的儿子要进行d-1次比较。
                         并且不能使使用简单移位计算算出父节点和子节点的位置。当二叉堆太大不能再内存在运行时,
                         d-堆和b树有点类似。
                         
                   缺点：不能对两个堆进行合并。             
                        
                        
                        
       5.4 可合并堆结构 
       
            5.4.1 左式堆
            
               5.4.1-1 描述：一种类似二叉的堆的结构,具有特定的堆性质。可以支持合并操作并且时间复杂度为O(logN),
                         支持合并操作的堆都是链式结构。
                
               5.4.1-2 零路径长(npl)：对任意一个节点X,X的零路径长为X到一个没有子两个节点的节点最短路径长。           
                         
               5.4.1-3 性质：
                         结构性质： 是一颗二叉树。是一个趋向左边的树。其中左子树的零路径长
                                  至少要等于右子树的零路径长。(L(npl) >= R(npl))。这样使得左式树
                                  向左深度加深,使得树不平衡,这有利于树的合并。
                        
                         堆序结构：节点按照优先排序。    
                         
                         
               5.4.1-4 定理：在右子树有r个节点的左式树一定有至少有2^(r-1)个节点。
               
               5.4.1-5 合并：所有操作都是基于合并,删除最小元,通过左右子树合并后形成新的左式树。
                            插入操作,也是合并操作,只是合并的只有一个元素的堆,在合并时对这种特殊
                            情况进行处理即可(添加元素时,元素必定没有左节点。而左式树必定具有左节点)。
                            
                            时间复杂度：O(log n),包括删除、插入
                               
                       具体操作：
                         
                         递归的实现；
                                  
                         1.将根节点较小的堆的右子树与根节点较大的堆递归进行合并。
                            (1)新根节点小于另一个堆的新根节点,将根节点小的新根节点切换为右节点。
                            (2)再和另一个堆的新根节点比较。
                            (3)如果还小于,继续(1)、(2)。
                            (4)直到小的新根节点大于另一个堆(大的)的新根节点,将两个新根节点调换后,重复(1)、(2)。
                             
                         2. (1)直到小的一方的新根节点没有右节点位置,将另一个堆((大的))的新根节点置为小的一方的
                                  新根节点的右节点。
                            (2)并且判断小的一方新根节点有没有破坏左式树的性质,如果有调换左右子树。
                            (3)并且更新小的一方新根节点npl(右子树npl + 1).
                            (4)沿着递归的路径对每个新根节点重复(1)、(2)、(3)。
                            
                         非递归实现：
                          
                         
               5.4.1-6 左式堆和二叉堆区别：二叉堆不支持合并,使用数组可以实现,左式堆由于支持合并使用链式的接口。
                        如果左式堆使用数组需要将一个数组拷贝到另一个数组,并且插入和移位,这是很耗时。二叉堆是
                        完全二叉树,左式堆二叉树(不平衡的)。
                        
               
               5.5 斜堆
               
               5.6 二项队列
               
                    5.6.1-1 描述：
                    
                             
               
               
               6.排序
                
                    6.1插入排序：交换相邻的元素方式进行排序。其平均时间复杂度为O(n^2),
                                如果对已经排序的进行排序,其时间复杂度为O(n)。最坏的时间复杂度为
                                序列是一个反序列,时间复杂度O(n^2)。
                            
                    6.1.1 实现：外循环n-1次,内循环对已排序的序列进行比较,如果满足,之前对应元素
                             向后移动一位,然后插入对应的位置。
                             
                        代码：
                        
                        public void insertSort(T [] arr){
                        
                            for(int i = 0; i < arr.length; i++){
                                T temp = arr[i];
                                int j;
                                for(j=i+1; j>0 && temp.compareTo(arr[j-1] ) < 0; j--){
                                    arr[j] = arr[j-1];
                                }
                                arr[j] = temp;
                            }
                        } 
                    
                                                                                                 